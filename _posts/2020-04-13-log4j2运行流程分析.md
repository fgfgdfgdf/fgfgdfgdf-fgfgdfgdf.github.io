---
layout: post
title: log4j2运行流程分析
---


## log4j2日志记录过程分析


### 例一
#### 配置
```xml
<!--最简单的控制台输出配置 -->
<configuration>
    <appenders>
        <Console name="ConsoleLog" target="SYSTEM_OUT">
            <PatternLayout pattern="[%d{yyyy-MM-dd HH:mm:ss:SSS} %p] [%thread] (%F:%L) %m%n"/>
        </Console>
    </appenders>

    <loggers>
        <root level="INFO">
            <AppenderRef ref="ConsoleLog"/>
        </root>
    </loggers>
</configuration>
```
#### 代码
```java
package com.sample;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Main {

    public static final Logger log1 = LoggerFactory.getLogger(Main.class); // 1

    public static void main(String[] args) {
        log1.info("this is log1 msg...");// 2
    }
}
```
#### 分析
log4j2使用方式无非两步,逐步分析
1) 使用LoggerFactory获取到对应Logger
2) 调用Logger对应方法打印日志

##### 使用LoggerFactory获取到对应Logger
    下面逐步分析
##### 1
    package:org.slf4j.LoggerFactory
```java
    // LoggerFactory类由slf4j提供,该类对外提供三个public方法
    // 1.1)通过1.3找到实现类,调用实现类(Log4jLoggerFactory)的 `public Logger getLogger(String name)`方法
    public static Logger getLogger(String name)
    // 1.2)间接调用方法1.1,参数为clazz的全类名
    public static Logger getLogger(Class<?> clazz)
    // 1.3)获取实现ILoggerFactory接口的类,这里是log4j2中的`Log4jLoggerFactory`
    public static ILoggerFactory getILoggerFactory()
```
     通过slf4j提供的接口方法,调用log4j2对slf4j的实现方法,
     此步在slf4j层面,很简单,下面分析Log4jLoggerFactory的getLogger()方法

##### 2
    package:org.apache.logging.slf4j.Log4jLoggerFactory
```java
    // 以下为Log4jLoggerFactory对ILoggerFactory接口的实现方法
    // 实现代码在Log4jLoggerFactory的父类AbstractLoggerAdapter中
    // 流程为 1)获取LoggerContext
    //        2)通过ontext获取name和Logger的map
    //        3)从map取出logger,若没有则新创建并缓存
    public L getLogger(final String name) {
        final LoggerContext context = getContext(); // 2.1 注意这里没有传递任何参数
        final ConcurrentMap<String, L> loggers = getLoggersInContext(context); //2.2
        final L logger = loggers.get(name);
        if (logger != null) {
            return logger;
        }
        loggers.putIfAbsent(name, newLogger(name, context)); // 2.3
        return loggers.get(name);
    }

    // 由步骤2.1中调用,
    protected LoggerContext getContext() {
        // 3.1 LogManager的LoggerContextFactory若是和类加载器有关,则获取调用者的class
         final Class<?> anchor = LogManager.getFactory().isClassLoaderDependent()
            ? StackLocatorUtil.getCallerClass(Log4jLoggerFactory.class, CALLER_PREDICATE): null;
        //最终都是调用LogManager的getContext()方法
        return anchor == null? LogManager.getContext(false): getContext(anchor); // 2.4
    }

```
             2.3说明logger的创建只与name和contex有关;
            2.2调用方法看到本类缓存了context->(name->logger)的关系表;
            2.4最终还是在调用LogManager的getContext方法,
            这里猜测LoggerContext可能和类加载器有关,下面继续分析

##### 3
    package:org.apache.logging.log4j.LogManager
```java
    // 2.4步骤中最终调用方法都是按如下形式写法
    // factory为LogManager中的LoggerContextFactory.由下面静态方法初始化
    try {
        return factory.getContext(FQCN, loader, null, currentContext); // 3.1
    } catch (final IllegalStateException ex) {
        return SimpleLoggerContextFactory.INSTANCE.getContext(FQCN, loader, null, currentContext);
    }

    // LogManager中factory是在static方法中加载初始化
    // 扫描类路径以查找所有日志记录实现,这里找到的factory是Log4jContextFactory
    static {
        final PropertiesUtil managerProps = PropertiesUtil.getProperties();
        final String factoryClassName = managerProps.getStringProperty(FACTORY_PROPERTY_NAME);
        // 这里尝试加载自定义的factoryClass
        if (factoryClassName != null) {
                try {
                    factory = LoaderUtil.newCheckedInstanceOf(factoryClassName, LoggerContextFactory.class);
                } catch (final Exception e) {
                }
        }
        //
        if (factory == null) {
            final SortedMap<Integer, LoggerContextFactory> factories = new TreeMap<>();
            if (ProviderUtil.hasProviders()) {
                // 扫描Provider实现,这里会加载Log4jProvider
                for (final Provider provider : ProviderUtil.getProviders()) {
                    final Class<? extends LoggerContextFactory> factoryClass = provider.loadLoggerContextFactory();
                    if (factoryClass != null) {
                        try {
                            // 调用无参构造实例化
                            factories.put(provider.getPriority(), factoryClass.newInstance());// 3.1
                        } catch (final Exception e) {
                        }
                     }
                }

                if (factories.isEmpty()) {
                     factory = SimpleLoggerContextFactory.INSTANCE;
                } else if (factories.size() == 1) {
                     factory = factories.get(factories.lastKey());
                } else {
                    factory = factories.get(factories.lastKey());
                }
            } else {
                factory = SimpleLoggerContextFactory.INSTANCE;
            }
        }
        LogManagerStatus.setInitialized(true);
    }

```
     通过3.1继续到Log4jContextFactory中分析

4

    package:org.apache.logging.log4j.core.impl.Log4jContextFactory

```java
    public LoggerContext getContext(final String fqcn, final ClassLoader loader, final Object externalContext,
                                    final boolean currentContext) {
        // selector为3.1中通过无参构造方法创建,这里是ClassLoaderContextSelector
        final LoggerContext ctx = selector.getContext(fqcn, loader, currentContext); // 4.1
        if (externalContext != null && ctx.getExternalContext() == null) {
            ctx.setExternalContext(externalContext);
        }
        if (ctx.getState() == LifeCycle.State.INITIALIZED) {
            ctx.start(); // 5.2
        }
        return ctx;
    }

```
    通过4.1获取LoggerContext,如果未STARTED,则调用start()
    LoggerContext的创建由4.1中ContextSelector的getContext方法创建,
    下面进入ClassLoaderContextSelector继续分析

5

       package:org.apache.logging.log4j.core.selector.ClassLoaderContextSelector

```java
    // 4.1的方法最终进入此方法

    public LoggerContext getContext(final String fqcn, final ClassLoader loader, final Map.Entry<String, Object> entry,
        final boolean currentContext, final URI configLocation) {
        if (currentContext) {
            final LoggerContext ctx = ContextAnchor.THREAD_CONTEXT.get();
            if (ctx != null) {
                return ctx;
            }
              return getDefault();
        } else if (loader != null) {
            return locateContext(loader, entry, configLocation);
        } else {
            final Class<?> clazz = StackLocatorUtil.getCallerClass(fqcn);
            if (clazz != null) {
                return locateContext(clazz.getClassLoader(), entry, configLocation);
            }
            final LoggerContext lc = ContextAnchor.THREAD_CONTEXT.get();
            if (lc != null) {
                 return lc;
            }
            return getDefault();
        }
    }

    private LoggerContext locateContext(final ClassLoader loaderOrNull, final Map.Entry<String, Object> entry,
            final URI configLocation) {
        // LOG4J2-477: class loader may be null
        final ClassLoader loader = loaderOrNull != null ? loaderOrNull : ClassLoader.getSystemClassLoader();
        final String name = toContextMapKey(loader);
        AtomicReference<WeakReference<LoggerContext>> ref = CONTEXT_MAP.get(name);
        if (ref == null) {
            if (configLocation == null) {
                ClassLoader parent = loader.getParent();
                while (parent != null) {

                    ref = CONTEXT_MAP.get(toContextMapKey(parent));
                    if (ref != null) {
                        final WeakReference<LoggerContext> r = ref.get();
                        final LoggerContext ctx = r.get();
                        if (ctx != null) {
                            return ctx;
                        }
                    }
                    parent = parent.getParent();
                    /*  In Tomcat 6 the parent of the JSP classloader is the webapp classloader which would be
                    configured by the WebAppContextListener. The WebAppClassLoader is also the ThreadContextClassLoader.
                    In JBoss 5 the parent of the JSP ClassLoader is the WebAppClassLoader which is also the
                    ThreadContextClassLoader. However, the parent of the WebAppClassLoader is the ClassLoader
                    that is configured by the WebAppContextListener.

                    ClassLoader threadLoader = null;
                    try {
                        threadLoader = Thread.currentThread().getContextClassLoader();
                    } catch (Exception ex) {
                        // Ignore SecurityException
                    }
                    if (threadLoader != null && threadLoader == parent) {
                        break;
                    } else {
                        parent = parent.getParent();
                    } */
                }
            }
            LoggerContext ctx = createContext(name, configLocation);
            if (entry != null) {
                ctx.putObject(entry.getKey(), entry.getValue());
            }
            LoggerContext newContext = CONTEXT_MAP.computeIfAbsent(name,
                    k -> new AtomicReference<>(new WeakReference<>(ctx))).get().get();
            if (newContext == ctx) {
                ctx.addShutdownListener(this);
            }
            return newContext;
        }
        final WeakReference<LoggerContext> weakRef = ref.get();
        LoggerContext ctx = weakRef.get();
        if (ctx != null) {
            if (entry != null && ctx.getObject(entry.getKey()) == null) {
                ctx.putObject(entry.getKey(), entry.getValue());
            }
            if (ctx.getConfigLocation() == null && configLocation != null) {
                LOGGER.debug("Setting configuration to {}", configLocation);
                ctx.setConfigLocation(configLocation);
            } else if (ctx.getConfigLocation() != null && configLocation != null
                    && !ctx.getConfigLocation().equals(configLocation)) {
                LOGGER.warn("locateContext called with URI {}. Existing LoggerContext has URI {}", configLocation,
                        ctx.getConfigLocation());
            }
            return ctx;
        }
        ctx = createContext(name, configLocation);
        if (entry != null) {
            ctx.putObject(entry.getKey(), entry.getValue());
        }
        ref.compareAndSet(weakRef, new WeakReference<>(ctx));
        return ctx;
    }

```

##### 调用Logger对应方法
