---
title: 计算机网络
date: 2020-05-29
layout: post
---

_______________________________________________________________

### OSI七层模型  

* 第七层:应用层
* 第六层:表现层
* 第五层:会话层
* 第四层:传输层
* 第三层:网络层
* 第二层:链路层
* 第一层:物理层

_______________________________________________________________
### 字节序
    
* 大端(big-endian):高位字节排放在内存的低地址端,低位字节排放在内存的高地址端  
* 小端(little-endian):低位字节排放在内存的低地址端,高位字节排放在内存的高地址端

高位字节/低位字节:以10进制899521为例,8这边为高位,1这边为低位

![img_bigEndian](/assets/image/Big-Endian.svg.png "big_endian")![img_littleEndian](/assets/image/Little-Endian.svg.png "little_Endian")

_______________________________________________________________

### 字符编码

_______________________________________________________________

### MTU
* `最大传输单元MTU(Maximum Transmission Unit,MTU),是指网络能够传输的最大数据包大小,以字节为单位`  
* `MTU是数据链路层的概念,指数据链路层对数据帧长度的限制`  
* `如果MTU超过了接收端所能够承受的最大值,或者是超过了发送路径上途经的某台设备所能够承受的最大值,
   就会造成报文分片甚至丢弃,加重网络传输的负担.如果太小,那实际传送的数据量就会过小,影响传输效率`
* `以太网MTU通常被设置为1500 byte`  
* `TCP的最大MSS计算为:1460=1500(MTU)- 20(IP Header) -20 (TCP Header)`

_______________________________________________________________

### MSL
* `最大传输单元MTU(Maximum Transmission Unit,MTU),是指网络能够传输的最大数据包大小,以字节为单位`
* `MTU是数据链路层的概念,指数据链路层对数据帧长度的限制`
* `如果MTU超过了接收端所能够承受的最大值,或者是超过了发送路径上途经的某台设备所能够承受的最大值,
  就会造成报文分片甚至丢弃,加重网络传输的负担.如果太小,那实际传送的数据量就会过小,影响传输效率`
* `以太网MTU通常被设置为1500 byte`
* `TCP的最大MSS计算为:1460=1500(MTU)- 20(IP Header) -20 (TCP Header)`

_______________________________________________________________

### IP

##### 1.报文格式
![img_ip_package](/assets/image/ip_package.png "ip_package")

_______________________________________________________________

### TCP

##### 1.报文格式  
![img_tcp_package](/assets/image/tcp_package.png "tcp_package")  

`TCP头最大长度:60 byte(固定头大小:20 byte,选项最大长度:40 byte)`  

资料偏移字段  
* `占4bit,可表示最大值为15;可用来计算TCP头的总长度的值`  
* `它以32bit为一个单位(图中的一行,也就是4 byte),所以TCP最大头长度来源为:15 * 4 byte`  

##### 2.状态转换  

S=服务器,C=客户端,S&C表示两者,S/C表示两者之一  

**LISTEN S**  
`服务器等待从任意远程TCP端口的连接请求,侦听状态`  
**SYN-SENT C**  
`客户在发送连接请求后等待匹配的连接请求,通过connect()函数向服务器发出一个同步（SYNC）信号后进入此状态`  
**SYN-RECEIVED S**  
`服务器已经收到并发送同步(SYNC)信号之后等待确认(ACK)请求`  
**ESTABLISHED S&C**  
`服务器与客户的连接已经打开,收到的数据可以发送给用户.数据传输步骤的正常情况,此时连接两端是平等的,这称作全连接`  
**FIN-WAIT-1 S&C**  
`主动关闭时调用close()函数发出FIN请求包,表示本方数据发送全部结束,等待对端的ACK确认包或FIN&ACK请求包`  
**FIN-WAIT-2 S&C**  
`主动关闭端在FIN-WAIT-1状态下收到ACK确认包,进入等待远程TCP的连接终止请求的半关闭状态.这时可以接收数据,但不再发送数据`  
**CLOSE-WAIT S&C**  
`被动关闭端接到FIN后,就发出ACK以回应FIN请求,并进入等待本地用户的连接终止请求的半关闭状态.这时可以发送数据,但不再接收数据`  
**CLOSING S&C**  
`在发出FIN后,又收到对方发来的FIN后,进入等待对方对己方的连接终止(FIN)的确认(ACK)的状态,少见`  
**LAST-ACK S&C**  
`被动关闭端全部数据发送完成之后,向主动关闭端发送FIN,进入等待确认包的状态`  
**TIME-WAIT S/C**  
`主动关闭端接收到FIN后,就发送ACK包,等待足够时间以确保被动关闭端收到了终止请求的确认包(按照RFC 793,一个连接可以在TIME-WAIT保持最大四分钟,即最大分段寿命(maximum segment lifetime)的2倍)`  
**CLOSED S&C**  
`完全没有连接`  


##### 3.三次握手
![img_tcp_connection](/assets/image/tcp_connection.png "tcp_connection")   

1. 客户端(通过执行connect函数)向服务器端发送一个SYN包,该包携带客户端为这个连接请求而设定的随机数A作为消息序列号 
2. 服务器端收到一个合法的SYN包后,把该包放入SYN队列中;回送一个SYN/ACK.ACK的确认码应为A+1,SYN/ACK包本身携带一个随机产生的序号B
3. 客户端收到SYN/ACK包后,发送一个ACK包,该包的序号被设定为A+1,而ACK的确认码则为B+1,然后客户端的connect函数成功返回.  
   当服务器端收到这个ACK包的时候,把请求帧从SYN队列中移出,放至ACCEPT队列中;这时accept函数如果处于阻塞状态,可以被唤醒,  
   从ACCEPT队列中取出ACK包,重新建立一个新的用于双向通信的sockfd,并返回  

##### 4.四次挥手
![img_tcp_deconnection](/assets/image/tcp_deconnection.png "tcp_deconnection")   ![img_tcp_close.svg.png](/assets/image/tcp_close.svg.png "tcp_close.svg.png")  


##### 5.TCP参数

* **tcp_syn_retries**  
    `syn包重传次数(默认5次, 1+2+4+8+16+32=63s后终止握手)`    
* **tcp_synack_retries**   
    `syn+ack包重传次数(默认5次, 1+2+4+8+16+32=63s后终止握手)`    
* **tcp_abort_on_overflow**  
    `server的accept队列满后,0(),1()`  

##### 6.流量控制
##### 7.拥塞控制





































