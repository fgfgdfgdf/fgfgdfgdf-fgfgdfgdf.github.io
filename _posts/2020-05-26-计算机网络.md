---
title: 计算机网络
date: 2020-05-29
layout: post
---

_______________________________________________________________

### OSI七层模型  

* 第七层:应用层
* 第六层:表现层
* 第五层:会话层
* 第四层:传输层
* 第三层:网络层
* 第二层:链路层
* 第一层:物理层

_______________________________________________________________
### 字节序
    
* **大端(big-endian):高位字节排放在内存的低地址端,低位字节排放在内存的高地址端**
* **小端(little-endian):低位字节排放在内存的低地址端,高位字节排放在内存的高地址端**

高位字节/低位字节:以10进制899521为例,8这边为高位,1这边为低位

![img_bigEndian](/assets/image/Big-Endian.svg.png "big_endian")![img_littleEndian](/assets/image/Little-Endian.svg.png "little_Endian")

_______________________________________________________________

### 字符编码

_______________________________________________________________

### TCP

##### 报文格式  
![img_tcp_package](/assets/image/tcp_package.png "tcp_package")  

##### 状态转换  

**LISTEN S**  
`服务器等待从任意远程TCP端口的连接请求,侦听状态`  
**SYN-SENT C**  
`客户在发送连接请求后等待匹配的连接请求,通过connect()函数向服务器发出一个同步（SYNC）信号后进入此状态`  
**SYN-RECEIVED S**  
`服务器已经收到并发送同步(SYNC)信号之后等待确认(ACK)请求`  
**ESTABLISHED S&C**  
`服务器与客户的连接已经打开,收到的数据可以发送给用户.数据传输步骤的正常情况,此时连接两端是平等的,这称作全连接`  
**FIN-WAIT-1 S&C**  
`(服务器或客户端)主动关闭端调用close()函数发出FIN请求包,表示本方的数据发送全部结束,等待TCP连接另一端的ACK确认包或FIN&ACK请求包`  
**FIN-WAIT-2 S&C**  
`主动关闭端在FIN-WAIT-1状态下收到ACK确认包,进入等待远程TCP的连接终止请求的半关闭状态。这时可以接收数据,但不再发送数据`  
**CLOSE-WAIT S&C**  
`被动关闭端接到FIN后,就发出ACK以回应FIN请求,并进入等待本地用户的连接终止请求的半关闭状态。这时可以发送数据,但不再接收数据`  
**CLOSING S&C**  
`在发出FIN后,又收到对方发来的FIN后,进入等待对方对己方的连接终止(FIN)的确认(ACK)的状态,少见`  
**LAST-ACK S&C**  
`被动关闭端全部数据发送完成之后,向主动关闭端发送FIN,进入等待确认包的状态`  
**TIME-WAIT S/C**  
`主动关闭端接收到FIN后,就发送ACK包,等待足够时间以确保被动关闭端收到了终止请求的确认包(按照RFC 793,一个连接可以在TIME-WAIT保证最大四分钟,即最大分段寿命(maximum segment lifetime)的2倍)`  
**CLOSED S&C**  
`完全没有连接`  


##### 三次握手
![img_tcp_connection](/assets/image/tcp_connection.png "tcp_connection")   

1. 客户端(通过执行connect函数)向服务器端发送一个SYN包,该包携带客户端为这个连接请求而设定的随机数A作为消息序列号 
2. 服务器端收到一个合法的SYN包后,把该包放入SYN队列中;回送一个SYN/ACK.ACK的确认码应为A+1,SYN/ACK包本身携带一个随机产生的序号B
3. 客户端收到SYN/ACK包后,发送一个ACK包,该包的序号被设定为A+1,而ACK的确认码则为B+1,然后客户端的connect函数成功返回.  
   当服务器端收到这个ACK包的时候,把请求帧从SYN队列中移出,放至ACCEPT队列中;这时accept函数如果处于阻塞状态,可以被唤醒,  
   从ACCEPT队列中取出ACK包,重新建立一个新的用于双向通信的sockfd,并返回  

##### 四次挥手
![img_tcp_deconnection](/assets/image/tcp_deconnection.png "tcp_deconnection")   ![img_tcp_close.svg.png](/assets/image/tcp_close.svg.png "tcp_close.svg.png")  


##### TCP参数

* **tcp_syn_retries**  
    `syn包重传次数(默认5次, 1+2+4+8+16+32=63s后终止握手)`    
* **tcp_synack_retries**   
    `syn+ack包重传次数(默认5次, 1+2+4+8+16+32=63s后终止握手)`    
* **tcp_abort_on_overflow**  
    `server的accept队列满后,0(),1()`  

##### 流量控制
##### 拥塞控制





































